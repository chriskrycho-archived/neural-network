module integrate_fire_module

use gamma_ksi_time_module

contains
subroutine integrate(V,Vstore,tstore,tts,ttl,ncount,grids,total,alpha,ksi,ksid,h,A,B,Jjtotal,jjdtotal,Jktotal,jkdtotal)

! Local variables:
implicit none
integer   :: grid, W(total), X(total), Y(total), Z(total), min, max, n, tts, ttl
logical   :: recent

! Variables passed by declaration:
integer   :: ncount, grids, total
real      :: V(total), Vstore(total), tstore(ttl,total), alpha(total), ksi(total), ksid(total)
real      :: Jjtotal(total), jjdtotal(total), Jktotal(total), jkdtotal(total)
real      :: h, A, B


! Integrate over all neurons:
ndo: do n=1,total

  ! Reset time for individual "neuron" to "fire" - 8 milliseconds:
  recent = (tstore(1,n) < 0.008d0)
  
  ! Now for any neuron that has fired recently (within 8 ms) set incoming current to 0 and hold the voltage at 0.
  recentif: if (recent) then
      
      Jjtotal(n) = 0
      jjdtotal(n) = 0
      Jktotal(n) = 0
      jkdtotal(n) = 0
      V(n) = 0
  
  ! If the neuron has NOT fired recently (within 8 milliseconds), incoming current is integrated and the neuron may fire:
  else
    
    ! W(n) includes all terms multiplied by the previous value of V(n) inside the Euler derivative term:
    W(n) = Vstore(n) * alpha(n) * alpha(n)
    
    ! X(n) is all the non-current terms remaining:
    X(n) = ksid(n) -  alpha(n) * ksi(n)
    
    ! Y(n) is all the current terms for internetwork synaptic current:
    Y(n) = A * (jjdtotal(n) - alpha(n) * Jjtotal(n))
    
    ! Z(n) is all the current terms for intranetwork synaptic current:
    Z(n) = B * (jkdtotal(n) - alpha(n) * Jktotal(n))
    
    ! The actual voltage equation is the sum of each of the above parts with the previous value of V(n):
    V(n) = Vstore(n) + h * (W(n) + X(n) + Y(n) + Z(n))    ! Note the format actually matches the form of an Euler integral
        
  end if recentif
  
enddo ndo

END SUBROUTINE integrate


! --------- !


subroutine firecheck(V,Vstore,fire,doesFire,total,tstore,ttl,ncount,h)

implicit none

! local variables:
integer :: n

! variables passed by reference:
real    :: V(total), Vstore(total), tstore(ttl,total), h
integer :: fire(total), total, ncount, ttl
logical :: doesFire

! Check if a given neuron fires, and if so reset the time. Also account for boundary condition on V (must be >= 0):

firestep: do n=1,total
  
  ! If the voltage on neuron n generated by integration (above) is greater than 1, the neuron fires.
  if (V(n) >= 1.0d0) then
    
    ! Indicate that this neuron has fired.
    fire(n) = 1
    doesFire = .true.
    
    ! The voltage stored for the next integration is 0.
    Vstore(n) = 0.0d0
          
    ! All previous times are stepped before setting the current time since firing to 0.
    call timestep(tstore,ttl,ncount,n,h,doesFire)
    
  ! If the voltage has been pushed below zero, it is reset to 0. Time since firing continues to increase.
  elseif (V(n) < 0.0d0) then
  
    ! The neuron does not fire:
    doesFire = .false.
    
    ! The voltage stored for the next integration is 0.
    Vstore(n) = 0.0d0
    
    ! All previous times are stepped before setting the current time since firing up by a step of size h.
    call timestep(tstore,ttl,ncount,n,h,doesFire)
        
  ! If the value neither exceeds the threshold nor is low, simply iterate the time since that neuron has fired and store V.
  else
  
    ! The neuron does not fire
    doesFire = .false.
    
    ! Store the value of V achieved in this cycle for the next integration.
    Vstore(n) = V(n)
    
    ! All previous times are stepped before setting the current time since firing up by a step of size h.
    call timestep(tstore,ttl,ncount,n,h,doesFire)
  
  end if

end do firestep
  
END subroutine firecheck

end module integrate_fire_module